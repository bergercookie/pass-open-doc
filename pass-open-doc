#!/usr/bin/env bash
# vi:syntax=sh
# vi:filetype=sh

# Current script decrypts and opens a gpg-encrypted document that is stored in
# the password-store of the *pass* Unix password manager. Under the hood uses
# xdg-mime to grab the file type and open it with the default application for
# its filetype.
#
# Currently runs on Linux platforms

# Created by argbash-init v2.6.1
# Rearrange the order of options below according to what you would like to see in the help message.
# ARG_OPTIONAL_SINGLE([gpg_id],[g],[gpg-id to use.],[$HOME/.password-store/.gpg-id])
# ARG_POSITIONAL_SINGLE([input-file],[i],[gpg-encrypted file to open. You can either use the full path to the file or just the name of the pass-stored item])
# ARG_HELP([Open a gpg-encrypted, optionally pass-stored, file])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.6.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

die()
{
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}

begins_with_short_option()
{
	local first_option all_short_options
	all_short_options='gh'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}



# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_input_file="gpg-encrypted file to open. You can either use the full path to the file or just the name of the pass-stored item"
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_gpg_id="$HOME/.password-store/.gpg-id"

print_help ()
{
	printf '%s\n' "Open a gpg-encrypted, optionally pass-stored, file"
	printf 'Usage: %s [-g|--gpg_id <arg>] [-h|--help] [<input-file>]\n' "$0"
	printf '\t%s\n' "<input-file>: i (default: 'gpg-encrypted file to open. You can either use the full path to the file or just the name of the pass-stored item')"
	printf '\t%s\n' "-g, --gpg_id: gpg-id to use. (default: '$HOME/.password-store/.gpg-id')"
	printf '\t%s\n' "-h, --help: Prints help"
}

parse_commandline ()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-g|--gpg_id)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_gpg_id="$2"
				shift
				;;
			--gpg_id=*)
				_arg_gpg_id="${_key##--gpg_id=}"
				;;
			-g*)
				_arg_gpg_id="${_key##-g}"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_positionals+=("$1")
				;;
		esac
		shift
	done
}


handle_passed_args_count ()
{
	test ${#_positionals[@]} -le 1 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect between 0 and 1, but got ${#_positionals[@]} (the last one was: '${_positionals[*]: -1}')." 1
}

assign_positional_args ()
{
	_positional_names=('_arg_input_file' )

	for (( ii = 0; ii < ${#_positionals[@]}; ii++))
	do
		eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


set -e

function print_fatal_msg() {

printf "%s\nExiting...\n" "$1"
exit 1

}

root="$HOME/.password-store/"

gpg_prog="$(which gpg)"
recipient=$(cat "$root/.gpg-id")
dst_file="/tmp/$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1)"

open_prog=
del_prog=
del_prog_flags=
if [ $(uname) == "Linux" ]; then
    del_prog=$(which shred)
    del_prog_flags="--remove"
elif [ $(uname) == "Darwin" ]; then
    del_prog=$(which srm)
else
    print_fatal_msg "Unknown platform \($(uname)\)"
fi

# Verify that the path exists
# set fpath
fpath_potential_full="$root/$_arg_input_file.gpg"
if [ -f "$_arg_input_file" ]; then
  fpath="$_arg_input_file"
  echo "pass-open-doc.in.sh:55 DEBUGGING STRING ==> 2"
elif [ -f "$fpath_potential_full" ]; then
  fpath="$fpath_potential_full"
  echo "pass-open-doc.in.sh:58 DEBUGGING STRING ==> 3"
else
  echo "fpath_potential_full:  ${fpath_potential_full}"
    print_fatal_msg "Neither \"$_arg_input_file\" or \"$fpath_potential_full\" exist."
fi

# Decrypt
${gpg_prog} --recipient "$recipient" --decrypt  --output "$dst_file" "$fpath"

# Don't use xdg-open as it it launched as a different process, so the shell
# cannot wait until it finished...
#
# Determine the mime type
# https://unix.stackexchange.com/questions/114224/open-file-with-default-program-and-wait-until-the-app-is-terminated
ftype=$(xdg-mime query filetype "$dst_file")
open_prog_raw=$(xdg-mime query default "$ftype")
open_prog=$(echo "$open_prog_raw" | sed 's/\..*//')

# remove the gibberish kde4-...Application.. from kde4 application names
open_prog=$(echo $open_prog | sed 's/kde4-\(.*\)Application.*/\1/')

${open_prog} "$dst_file"

# Make sure I delete the destination file
printf "Removing output file...\n"
${del_prog} ${del_prog_flags} "$dst_file"
printf "Done!\n"
exit 0
# ] <-- needed because of Argbash
